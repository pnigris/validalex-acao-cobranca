"use strict";Object.defineProperty(exports, "__esModule", {value: true});
























var _chunk23VLASYPcjs = require('./chunk-23VLASYP.cjs');

// src/del.ts
async function del(urlOrPathname, options) {
  await _chunk23VLASYPcjs.requestApi.call(void 0, 
    "/delete",
    {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({
        urls: Array.isArray(urlOrPathname) ? urlOrPathname : [urlOrPathname]
      }),
      signal: options == null ? void 0 : options.abortSignal
    },
    options
  );
}

// src/head.ts
async function head(urlOrPathname, options) {
  const searchParams = new URLSearchParams({ url: urlOrPathname });
  const response = await _chunk23VLASYPcjs.requestApi.call(void 0, 
    `?${searchParams.toString()}`,
    // HEAD can't have body as a response, so we use GET
    {
      method: "GET",
      signal: options == null ? void 0 : options.abortSignal
    },
    options
  );
  return {
    url: response.url,
    downloadUrl: response.downloadUrl,
    pathname: response.pathname,
    size: response.size,
    contentType: response.contentType,
    contentDisposition: response.contentDisposition,
    cacheControl: response.cacheControl,
    uploadedAt: new Date(response.uploadedAt),
    etag: response.etag
  };
}

// src/list.ts
async function list(options) {
  var _a;
  const searchParams = new URLSearchParams();
  if (options == null ? void 0 : options.limit) {
    searchParams.set("limit", options.limit.toString());
  }
  if (options == null ? void 0 : options.prefix) {
    searchParams.set("prefix", options.prefix);
  }
  if (options == null ? void 0 : options.cursor) {
    searchParams.set("cursor", options.cursor);
  }
  if (options == null ? void 0 : options.mode) {
    searchParams.set("mode", options.mode);
  }
  const response = await _chunk23VLASYPcjs.requestApi.call(void 0, 
    `?${searchParams.toString()}`,
    {
      method: "GET",
      signal: options == null ? void 0 : options.abortSignal
    },
    options
  );
  if ((options == null ? void 0 : options.mode) === "folded") {
    return {
      folders: (_a = response.folders) != null ? _a : [],
      cursor: response.cursor,
      hasMore: response.hasMore,
      blobs: response.blobs.map(mapBlobResult)
    };
  }
  return {
    cursor: response.cursor,
    hasMore: response.hasMore,
    blobs: response.blobs.map(mapBlobResult)
  };
}
function mapBlobResult(blobResult) {
  return {
    url: blobResult.url,
    downloadUrl: blobResult.downloadUrl,
    pathname: blobResult.pathname,
    size: blobResult.size,
    uploadedAt: new Date(blobResult.uploadedAt),
    etag: blobResult.etag
  };
}

// src/copy.ts
async function copy(fromUrlOrPathname, toPathname, options) {
  if (!options) {
    throw new (0, _chunk23VLASYPcjs.BlobError)("missing options, see usage");
  }
  if (options.access !== "public") {
    throw new (0, _chunk23VLASYPcjs.BlobError)('access must be "public"');
  }
  if (toPathname.length > _chunk23VLASYPcjs.MAXIMUM_PATHNAME_LENGTH) {
    throw new (0, _chunk23VLASYPcjs.BlobError)(
      `pathname is too long, maximum length is ${_chunk23VLASYPcjs.MAXIMUM_PATHNAME_LENGTH}`
    );
  }
  for (const invalidCharacter of _chunk23VLASYPcjs.disallowedPathnameCharacters) {
    if (toPathname.includes(invalidCharacter)) {
      throw new (0, _chunk23VLASYPcjs.BlobError)(
        `pathname cannot contain "${invalidCharacter}", please encode it if needed`
      );
    }
  }
  const headers = {};
  if (options.addRandomSuffix !== void 0) {
    headers["x-add-random-suffix"] = options.addRandomSuffix ? "1" : "0";
  }
  if (options.allowOverwrite !== void 0) {
    headers["x-allow-overwrite"] = options.allowOverwrite ? "1" : "0";
  }
  if (options.contentType) {
    headers["x-content-type"] = options.contentType;
  }
  if (options.cacheControlMaxAge !== void 0) {
    headers["x-cache-control-max-age"] = options.cacheControlMaxAge.toString();
  }
  if (options.ifMatch) {
    headers["x-if-match"] = options.ifMatch;
  }
  const params = new URLSearchParams({
    pathname: toPathname,
    fromUrl: fromUrlOrPathname
  });
  const response = await _chunk23VLASYPcjs.requestApi.call(void 0, 
    `?${params.toString()}`,
    {
      method: "PUT",
      headers,
      signal: options.abortSignal
    },
    options
  );
  return {
    url: response.url,
    downloadUrl: response.downloadUrl,
    pathname: response.pathname,
    contentType: response.contentType,
    contentDisposition: response.contentDisposition,
    etag: response.etag
  };
}

// src/index.ts
var put = _chunk23VLASYPcjs.createPutMethod.call(void 0, {
  allowedOptions: [
    "cacheControlMaxAge",
    "addRandomSuffix",
    "allowOverwrite",
    "contentType",
    "ifMatch"
  ]
});
var createMultipartUpload = _chunk23VLASYPcjs.createCreateMultipartUploadMethod.call(void 0, {
  allowedOptions: [
    "cacheControlMaxAge",
    "addRandomSuffix",
    "allowOverwrite",
    "contentType",
    "ifMatch"
  ]
});
var createMultipartUploader = _chunk23VLASYPcjs.createCreateMultipartUploaderMethod.call(void 0, {
  allowedOptions: [
    "cacheControlMaxAge",
    "addRandomSuffix",
    "allowOverwrite",
    "contentType",
    "ifMatch"
  ]
});
var uploadPart = _chunk23VLASYPcjs.createUploadPartMethod.call(void 0, {
  allowedOptions: [
    "cacheControlMaxAge",
    "addRandomSuffix",
    "allowOverwrite",
    "contentType"
  ]
});
var completeMultipartUpload = _chunk23VLASYPcjs.createCompleteMultipartUploadMethod.call(void 0, {
  allowedOptions: [
    "cacheControlMaxAge",
    "addRandomSuffix",
    "allowOverwrite",
    "contentType"
  ]
});


























exports.BlobAccessError = _chunk23VLASYPcjs.BlobAccessError; exports.BlobClientTokenExpiredError = _chunk23VLASYPcjs.BlobClientTokenExpiredError; exports.BlobContentTypeNotAllowedError = _chunk23VLASYPcjs.BlobContentTypeNotAllowedError; exports.BlobError = _chunk23VLASYPcjs.BlobError; exports.BlobFileTooLargeError = _chunk23VLASYPcjs.BlobFileTooLargeError; exports.BlobNotFoundError = _chunk23VLASYPcjs.BlobNotFoundError; exports.BlobPathnameMismatchError = _chunk23VLASYPcjs.BlobPathnameMismatchError; exports.BlobPreconditionFailedError = _chunk23VLASYPcjs.BlobPreconditionFailedError; exports.BlobRequestAbortedError = _chunk23VLASYPcjs.BlobRequestAbortedError; exports.BlobServiceNotAvailable = _chunk23VLASYPcjs.BlobServiceNotAvailable; exports.BlobServiceRateLimited = _chunk23VLASYPcjs.BlobServiceRateLimited; exports.BlobStoreNotFoundError = _chunk23VLASYPcjs.BlobStoreNotFoundError; exports.BlobStoreSuspendedError = _chunk23VLASYPcjs.BlobStoreSuspendedError; exports.BlobUnknownError = _chunk23VLASYPcjs.BlobUnknownError; exports.completeMultipartUpload = completeMultipartUpload; exports.copy = copy; exports.createFolder = _chunk23VLASYPcjs.createFolder; exports.createMultipartUpload = createMultipartUpload; exports.createMultipartUploader = createMultipartUploader; exports.del = del; exports.getDownloadUrl = _chunk23VLASYPcjs.getDownloadUrl; exports.head = head; exports.list = list; exports.put = put; exports.uploadPart = uploadPart;
//# sourceMappingURL=index.cjs.map